# -*- coding: utf-8 -*-
# Generated by Django 1.10.5 on 2017-01-22 09:02
from __future__ import unicode_literals

# import os
import os.path as op
import glob
import pandas as pd
import tempfile
import zipfile
import sqlite3

from django.conf import settings
from django.db import migrations
from django.contrib.auth.models import User
from papers.models import Tag, Paper


QUERY = """
SELECT

CAST(substr(publication_date, 3, 4) AS INTEGER) AS year,

author_string as authors,
full_author_string as full_authors,

CASE
    WHEN attributed_subtitle IS NULL THEN attributed_title
    ELSE attributed_title || ' - ' || attributed_subtitle
END AS title,

citekey,
tag_string as tags,
rating,
notes,
read_status,
summary,
group_concat(Annotation.text, "\n\n") as annotations,
strftime('%Y-%m-%d', datetime(imported_date, 'unixepoch')) as imported_date,
group_concat(PDF.path) as path
FROM Publication
LEFT JOIN PDF ON PDF.object_id = Publication.uuid
AND PDF.mime_type = "application/pdf"
LEFT JOIN Annotation ON Annotation.object_id = PDF.uuid
WHERE citekey IS NOT NULL
AND full_authors IS NOT NULL
GROUP BY citekey
ORDER BY publication_date ASC
"""


def load_papers3_database():
    path = settings.PAPERS_LIBRARY_PATH
    path = glob.glob(op.join(path, 'CompressedCheckpoints', 'Database.*'))[0]
    with tempfile.TemporaryDirectory() as temp_dir:
        with zipfile.ZipFile(path) as f:
            f.extractall(temp_dir)
        temp_path = op.join(temp_dir, op.basename(path))
        db = sqlite3.connect('file:' + temp_path + '?mode=ro', uri=True)
        c = db.cursor()
        r = c.execute(QUERY)
        columns = [_[0] for _ in r.description]
        papers = r.fetchall()
        df = pd.DataFrame.from_records(papers,
                                       #  index='citekey',
                                       columns=columns,
                                       )
        db.close()
        # Remove citekey duplicates.
        # df = df.drop_duplicates('citekey')
        return df


def flatten(l):
    return [item for sublist in l for item in sublist if item]


def import_data(apps, schema_editor):
    # Create super user.
    User.objects.create_superuser(username='admin',
                                  password='admin',
                                  email='',
                                  )

    df = load_papers3_database()

    # Import tags.
    tags = sorted(set(_.strip()
                      for _ in set(flatten(df.tags.str.split(',').tolist()))))
    for tag in tags:
        Tag(name=tag).save()

    # Import papers.
    # 'year', 'authors', 'full_authors', 'title', 'tags',
    # 'rating', 'notes', 'read_status', 'imported_date', 'path'
    def _iter_paper():
        for _, row in df.iterrows():
            d = dict(row)
            del d['tags']
            d['year'] = int(d['year']) if d['year'] > 0 else None
            d['rating'] = int(d['rating']) if d['rating'] > 0 else None
            d['pdf_path'] = (d.pop('path', '') or '').split(',')[0].strip()
            d['read_status'] = d['read_status'] != 0
            if not d['authors']:
                d['authors'] = (d['full_authors'].split(',')[0].split(' ')[-1]
                                + ' et al.')
            p = Paper(**d)
            yield p

    Paper.objects.bulk_create(_iter_paper())

    # Add tags.
    for _, row in df.iterrows():
        paper = Paper.objects.get(citekey=row.citekey)
        paper.tags.add(*[Tag.objects.get(name=tag.strip())
                         for tag in row.tags.split(',') if tag.strip()])


class Migration(migrations.Migration):

    dependencies = [
        ('papers', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(import_data),
    ]
